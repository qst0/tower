<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Tower</title>
<style>
  body { font-family: monospace; background: #111; color: #eee; padding: 20px; }
  button { background: #333; color: #fff; border: 1px solid #666; padding: 6px 12px; margin: 4px; cursor: pointer; }
  button:disabled { opacity: 0.5; cursor: default; }
  #log { margin-top: 20px; white-space: pre-wrap; border-top: 1px solid #333; padding-top: 10px; }
  #saveButtons { margin-top: 10px; }
</style>
</head>
<body>
<h1>Mage‚Äôs Tower</h1>
<p>Energy: <span id="energy">0</span> | Mana: <span id="mana">0</span> | Lore: <span id="lore">0</span> | Floor: <span id="floor">1</span> | Tempo: <span id="tempo">0</span></p>
<p id="status"></p>

<!-- Timer message for Meditate/Forced Rest appears here, under the action buttons -->


<div id="actions">
  <button id="focusBtn">Focus (+1 Mana) üí´</button>
  <button id="restBtn">Meditate (+5 Energy) üßò</button>
  <button id="studyBtn" style="display:none;">Study Glyph (costs 5 Mana) üìú</button>
  <button id="climbBtn" style="display:none;">Climb the Tower (costs 5 Energy) üßó</button>
</div>
<!-- Dedicated timer message area directly under the action buttons -->
<p id="timerMessage" style="min-height:1em;margin-top:0.5em;margin-bottom:0;"></p>
<div style="margin-top:12px;">
  <button id="showReadmeBtn">Show Game Mechanics üìñ</button>
</div>



<div id="saveButtons">
  <button id="saveBtn">Save Game</button>
  <button id="loadBtn">Load Game</button>
  <button id="exportBtn">Export Save</button>
  <button id="importBtn">Import Save</button>
  <input type="file" id="fileInput" style="display:none;">
</div>

<div id="log"></div>

<script>
// ---- README/Mechanics Modal Logic ----
const showReadmeBtn = document.getElementById("showReadmeBtn");
const logDiv = document.getElementById("log");
let logBackup = null;
let readmeActive = false;


// Simple Markdown to HTML (very basic, only for this README)
function markdownToHtml(md) {
  // Escape HTML
  md = md.replace(/[&<>]/g, function(c) {
    return {'&':'&amp;','<':'&lt;','>':'&gt;'}[c];
  });
  // Headers
  md = md.replace(/^### (.*)$/gm, '<h3>$1</h3>');
  md = md.replace(/^## (.*)$/gm, '<h2>$1</h2>');
  md = md.replace(/^# (.*)$/gm, '<h1>$1</h1>');
  // Bold
  md = md.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  // Italics
  md = md.replace(/\*(.+?)\*/g, '<em>$1</em>');
  // Unordered lists
  md = md.replace(/^\s*[\*\-] (.*)$/gm, '<li>$1</li>');
  md = md.replace(/(<li>[\s\S]+?<\/li>)/g, '<ul>$1</ul>');
  // Tables (very simple)
  md = md.replace(/\|(.+)\|\n\|([-\s\|]+)\|\n((\|.*\|\n)+)/g, function(_, head, dash, rows) {
    const ths = head.split('|').map(s=>s.trim()).filter(Boolean).map(s=>`<th>${s}</th>`).join('');
    const trs = rows.trim().split('\n').map(row=>{
      const tds = row.split('|').map(s=>s.trim()).filter(Boolean).map(s=>`<td>${s}</td>`).join('');
      return `<tr>${tds}</tr>`;
    }).join('');
    return `<table><thead><tr>${ths}</tr></thead><tbody>${trs}</tbody></table>`;
  });
  // Paragraphs
  md = md.replace(/([^\n>])\n([^\n#\-\*\|])/g, '$1<br>$2');
  // Line breaks for single newlines (not after block tags)
  md = md.replace(/\n{2,}/g, '</p><p>');
  md = '<p>' + md + '</p>';
  // Remove empty <p></p>
  md = md.replace(/<p><\/p>/g, '');
  // Remove nested <ul><ul>... (fix double wrap from above)
  md = md.replace(/(<ul>)+/g, '<ul>');
  md = md.replace(/(<\/ul>)+/g, '</ul>');
  return md;
}

// --- Embedded fallback README text (update this as needed) ---
const readmeText = `

# readme.md

## Notes

So I have a pretty nice setup now. I'm making a game I can play between playing the current game I love, Torn.com

## Button Unlock Guide

This table explains when each action button becomes visible and usable in tower:

| Button | Unlock Condition | Usability Requirement | Mechanic |
|--------|-----------------|---------------------|----------|
| Focus üí´ | Always available | Energy ‚â• 1, not meditating | Converts 1 Energy into 1 Mana. Can be repeated by holding the button. |
| Meditate üßò | Always available | Not already meditating | Restores 5 Energy over 5 seconds. No repeated hold; disables other actions during meditation. |
| Study Glyph üìú | Lore ‚â• 2 (auto-unlocked) | Mana ‚â• 5, not meditating | Spend 5 Mana to gain 1 Lore. Can be repeated by holding the button. |
| Climb üßó | Lore ‚â• 4 (auto-unlocked) | Enough Energy for current floor, not meditating | Spend Energy to ascend a floor. Special floor events may occur. |

## Game Mechanics

### Resources
* **Energy**: Required for most actions, especially climbing. Regenerates slowly over time and can be restored by resting.
* **Mana**: Used for magical actions such as studying glyphs. Gained by focusing and regenerates slowly over time.
* **Lore**: Represents your knowledge of the tower. Gained by studying, climbing, and discovering secrets. Unlocks new abilities as it increases.
* **Tempo**: Increases if you reach Floor 10 quickly. Represents your speed and mastery over the tower's challenges.
* **Floor**: Indicates your current progress up the tower. Higher floors are harder and may introduce special events.

### Actions
* **Focus üí´**: Converts 1 Energy into 1 Mana. Hold the button to repeat the action quickly as long as you have energy.
* **Meditate üßò**: Meditate for 5 seconds to restore 5 Energy. During meditation, all other actions are disabled.
* **Study Glyph üìú**: (Unlocked after gaining enough Lore) Spend 5 Mana to gain 1 Lore. Hold the button to repeat as long as you have mana.
* **Climb the Tower üßó**: (Unlocked after gaining enough Lore) Spend Energy to ascend one floor. The energy cost increases at higher floors.

### Inventory
* **Energy Potion**: Restores energy when used. Found randomly while climbing.
* **Mana Crystal**: Restores mana when used. Found randomly while climbing.
* **Glyph Shard**: Protects you from magical traps (especially on Floor 8). Found randomly while climbing.

### Random Events
* Each time you climb, there is a chance for a random event to occur. These can restore or drain your energy or mana, grant Lore, or force you to rest.
* There is also a chance to find inventory items while climbing.

### Special Floor Mechanics
* **Floor 5:** You must choose a path: *left* (costs more energy but grants mana) or *right* (normal cost, no bonus).
* **Floor 8:** A mystical trap is triggered. If you have a Glyph Shard, it protects you; otherwise, you lose extra energy.
* **Every 3 Floors:** Gain 1 Lore as you climb to a new tier of the tower.
* **Floor 10:** Reaching this floor quickly (within 2 minutes) grants you extra Tempo.

### Unlocks
* Studying and climbing are unlocked as you gain Lore by performing actions and progressing in the tower.

## Launch Checklist (Automagician / tower)

This checklist tracks all steps needed to prepare for launch. Keep it updated as progress is made.

### 1Ô∏è‚É£ Domain & Hosting
- [ ] Secure domain (AUTOMAGITION.COM or preferred)
- [ ] Set up DNS & hosting (GitHub Pages, Netlify, Vercel, or custom server)
- [ ] Configure HTTPS / SSL certificate

### 2Ô∏è‚É£ Game Code & Version Control
- [ ] Ensure final stable build in \`tower.html\`
- [ ] Use Git for version control with commits and \`.gitignore\`
- [ ] Backup saves and dev notes

### 3Ô∏è‚É£ Assets & Design
- [ ] Finalize UI/UX (buttons, log, status indicators)
- [ ] Polish styles (colors, fonts, readability)
- [ ] Add sounds / effects if desired
- [ ] Prepare screenshots / GIFs for marketing

### 4Ô∏è‚É£ Features & Testing
- [ ] Verify game loop, idle regen, resource calculations
- [ ] Test floor progression, tempo tracking, rest/focus mechanics
- [ ] Ensure save/load/export/import works correctly
- [ ] Cross-browser testing (Chrome, Firefox, Safari)

### 5Ô∏è‚É£ Marketing & Launch Prep
- [ ] Create README / dev notes for users
- [ ] Prepare social media / blog posts
- [ ] Consider teaser videos or GIFs
- [ ] Write press or community announcements

### 6Ô∏è‚É£ Launch & Monitoring
- [ ] Upload final build to hosting / domain
- [ ] Monitor player feedback and bug reports
- [ ] Plan post-launch updates and lore expansions
`;

function showReadme() {
  if (readmeActive) return;
  readmeActive = true;
  // Backup log
  logBackup = logDiv.innerHTML;
  // Disable all action buttons
  disableActions(true);
  document.getElementById("showReadmeBtn").disabled = true;
  // Show loading indicator
  logDiv.innerHTML =
    '<div id="readmeView" style="background:#181818;padding:16px 12px;border-radius:8px;max-height:60vh;overflow:auto;">' +
    '<button id="closeReadmeBtn" style="float:right;background:#444;margin-left:8px;">Close</button>' +
    '<h2 style="margin-top:0;">Game Mechanics üìñ</h2>' +
    '<p>Loading...</p>' +
    '</div>';
  // Attach close handler immediately for responsiveness
  document.getElementById("closeReadmeBtn").onclick = closeReadme;
  // Try fetching readme.md, but fall back to embedded if fails (e.g. file://)
  fetch('readme.md').then(resp => {
    if (!resp.ok) throw new Error("Failed to load readme.md");
    return resp.text();
  }).then(md => {
    if (!readmeActive) return;
    logDiv.innerHTML =
      '<div id="readmeView" style="background:#181818;padding:16px 12px;border-radius:8px;max-height:60vh;overflow:auto;">' +
      '<button id="closeReadmeBtn" style="float:right;background:#444;margin-left:8px;">Close</button>' +
      '<h2 style="margin-top:0;">Game Mechanics üìñ</h2>' +
      markdownToHtml(md) +
      '</div>';
    document.getElementById("closeReadmeBtn").onclick = closeReadme;
  }).catch(err => {
    // Fallback: use embedded readmeText
    if (!readmeActive) return;
    logDiv.innerHTML =
      '<div id="readmeView" style="background:#181818;padding:16px 12px;border-radius:8px;max-height:60vh;overflow:auto;">' +
      '<button id="closeReadmeBtn" style="float:right;background:#444;margin-left:8px;">Close</button>' +
      '<h2 style="margin-top:0;">Game Mechanics üìñ</h2>' +
      markdownToHtml(readmeText) +
      '<p style="color:#f66;font-size:90%;margin-top:12px;">(Displayed from built-in copy. <span style="opacity:0.7;">Could not load <code>readme.md</code> directly.)</span></p>' +
      '</div>';
    document.getElementById("closeReadmeBtn").onclick = closeReadme;
  });
}

function closeReadme() {
  if (!readmeActive) return;
  readmeActive = false;
  // Restore log
  logDiv.innerHTML = logBackup;
  // Re-enable action buttons
  disableActions(game.resting ? true : false);
  document.getElementById("showReadmeBtn").disabled = false;
}

showReadmeBtn.addEventListener("click", showReadme);
const game = {
  energy: 0,
  mana: 0,
  lore: 0,
  unlocked: { study: false },
  lastTick: Date.now(),
  floor: 1,
  tempo: 0,
  startTime: null,
  resting: false,
  inventory: { "Energy Potion": 0, "Mana Crystal": 0, "Glyph Shard": 0 },
  logHistory: [],
};

let autosavePending = false;
function scheduleAutosave() {
  if (autosavePending) return;
  autosavePending = true;
  const flush = () => {
    autosavePending = false;
    saveGame();
  };
  if (typeof queueMicrotask === "function") {
    queueMicrotask(flush);
  } else {
    setTimeout(flush, 0);
  }
}

// ---- Helpers for logging ----
function pad(num, size) {
  let s = num.toString();
  while (s.length < size) s = "0" + s;
  return s;
}

function getTimestamp() {
  const d = new Date();
  return d.getFullYear().toString() +
         pad(d.getMonth() + 1, 2) +
         pad(d.getDate(), 2) +
         pad(d.getHours(), 2) +
         pad(d.getMinutes(), 2) +
         pad(d.getSeconds(), 2) +
         pad(d.getMilliseconds(), 3).slice(0,2); // NN = first two digits of ms
}

function getRandomHex(len) {
  let result = "";
  const hexChars = "0123456789abcdef";
  for (let i = 0; i < len; i++) {
    result += hexChars[Math.floor(Math.random() * 16)];
  }
  return result;
}

// ---- Log function with timestamp and hash ----
function log(text) {
  const timestamp = getTimestamp();
  const hash = getRandomHex(8);
  const entry = `[${timestamp}][${hash}] ${text}`;
  // Add new log entry to the top
  game.logHistory.unshift(entry);
  const logDiv = document.getElementById("log");
  // Render newest at top
  logDiv.textContent = game.logHistory.join('\n');
  logDiv.scrollTop = 0;
  scheduleAutosave();
}

// ---- Game Loop ----
function tick() {
  const now = Date.now();
  const elapsed = (now - game.lastTick) / 1000;
  game.lastTick = now;

  // passive regen (increased for early progress)
  game.energy += elapsed * 0.2; // +0.2 energy/sec
  game.mana += elapsed * 0.1;  // +0.1 mana/sec

  updateUI();
  scheduleAutosave();
}

setInterval(tick, 1000);

// ---- UI Updates ----
function disableActions(state) {
  document.getElementById("focusBtn").disabled = state;
  document.getElementById("restBtn").disabled = state;
  document.getElementById("studyBtn").disabled = state || (!game.unlocked.study || game.mana < 5);
  document.getElementById("climbBtn").disabled = state || (!game.unlocked.climb || game.energy < getFloorCost(game.floor));
}

function updateUI() {
  document.getElementById("energy").textContent = Math.floor(game.energy);
  document.getElementById("mana").textContent = Math.floor(game.mana);
  document.getElementById("lore").textContent = game.lore;
  document.getElementById("floor").textContent = game.floor;
  document.getElementById("tempo").textContent = game.tempo;

  document.getElementById("studyBtn").style.display = game.unlocked.study ? "inline-block" : "none";
  document.getElementById("studyBtn").disabled = game.resting || game.mana < 5;

  document.getElementById("climbBtn").style.display = game.unlocked.climb ? "inline-block" : "none";
  document.getElementById("climbBtn").disabled = game.resting || game.energy < getFloorCost(game.floor);

  // Only update action buttons if not viewing README
  if (!readmeActive) {
    if (game.resting) {
      disableActions(true);
    } else {
      disableActions(false);
    }
    document.getElementById("showReadmeBtn").disabled = false;
  } else {
    disableActions(true);
    document.getElementById("showReadmeBtn").disabled = true;
  }
}

// ---- Helpers ----
function getFloorCost(floor) {
  if (floor >= 1 && floor <= 3) return 4;
  if (floor >= 4 && floor <= 6) return 6;
  if (floor >= 7 && floor <= 10) return 8;
  return 8; // default for beyond floor 10 if needed
}

// ---- Inventory ----
function addItem(item) {
  if (!game.inventory[item]) game.inventory[item] = 0;
  game.inventory[item]++;
  log(`You found a ${item}! Inventory now: ${item} x${game.inventory[item]}`);
  console.log(`Inventory: ${item} x${game.inventory[item]}`);
}

function useItem(item) {
  if (game.inventory[item] > 0) {
    game.inventory[item]--;
    log(`You used a ${item}. Inventory now: ${item} x${game.inventory[item]}`);
    console.log(`Inventory: ${item} x${game.inventory[item]}`);
    return true;
  }
  return false;
}

// ---- Random Floor Events ----
function randomFloorEvent() {
  const events = [
    () => { 
      game.energy += 2; 
      log(`You found a hidden energy spring! Energy +2 (Energy: ${Math.floor(game.energy)})`); 
    },
    () => { 
      game.mana += 2; 
      log(`A mana crystal glows nearby. Mana +2 (Mana: ${Math.floor(game.mana)})`); 
    },
    () => { 
      game.lore++; 
      log(`You discover ancient runes. Lore +1 (Lore: ${game.lore})`); 
    },
    () => {
      const lost = Math.min(2, Math.floor(game.energy));
      game.energy -= lost;
      log(`A sudden chill drains your strength. Energy -${lost} (Energy: ${Math.floor(game.energy)})`);
    },
    () => {
      const lost = Math.min(2, Math.floor(game.mana));
      game.mana -= lost;
      log(`A magical backlash saps your mana. Mana -${lost} (Mana: ${Math.floor(game.mana)})`);
    },
    () => {
      log("A mysterious force forces you to rest!");
      game.resting = true;
      disableActions(true);
      const timerMsgEl = document.getElementById("timerMessage");
      let remaining = 5;
      timerMsgEl.textContent = "Forced Rest... " + remaining + "s remaining";
      const interval = setInterval(() => {
        remaining--;
        if (remaining > 0) {
          timerMsgEl.textContent = "Forced Rest... " + remaining + "s remaining";
        } else {
          clearInterval(interval);
          timerMsgEl.textContent = "";
          game.resting = false;
          disableActions(false);
          log("You recover from the forced rest.");
          updateUI();
        }
      }, 1000);
    }
  ];
  const eventIndex = Math.floor(Math.random() * events.length);
  events[eventIndex]();
}

// ---- Actions ----

// Repeated action helper for focus
function performFocusRepeatedly() {
  if (game.energy < 1) {
    log("You are too tired to focus.");
    return 0;
  }
  let count = 0;
  while (game.energy >= 1) {
    game.energy -= 1;
    game.mana++;
    count++;
  }
  if (count > 0) {
    gainLoreIfFirst("focus", "You feel a pulse of magic. Mana flows at the cost of your strength.");
    log(`Focused ${count} times: Energy -${count} (Energy: ${Math.floor(game.energy)}), Mana +${count} (Mana: ${Math.floor(game.mana)})`);
  }
  return count;
}

// Repeated action helper for study
function performStudyRepeatedly() {
  if (!game.unlocked.study || game.mana < 5) {
    return 0;
  }
  let count = 0;
  while (game.mana >= 5) {
    game.mana -= 5;
    gainLoreIfFirst("study", "You study the glyphs and glimpse deeper knowledge...");
    game.lore++;
    count++;
  }
  if (count > 0) {
    log(`You study ancient glyphs ${count} times. Mana -${count * 5} (Mana: ${Math.floor(game.mana)}), Lore +${count} (Lore: ${game.lore})`);
  }
  return count;
}

// Focus button repeated action on mousedown/up
let focusInterval = null;
document.getElementById("focusBtn").addEventListener("mousedown", () => {
  if (game.resting) return;
  if (focusInterval) return;
  // Perform once immediately
  performFocusRepeatedly();
  focusInterval = setInterval(() => {
    if (game.resting) {
      clearInterval(focusInterval);
      focusInterval = null;
      return;
    }
    if (game.energy < 1) {
      clearInterval(focusInterval);
      focusInterval = null;
      return;
    }
    performFocusRepeatedly();
    updateUI();
  }, 500);
});
document.getElementById("focusBtn").addEventListener("mouseup", () => {
  if (focusInterval) {
    clearInterval(focusInterval);
    focusInterval = null;
  }
});
document.getElementById("focusBtn").addEventListener("mouseleave", () => {
  if (focusInterval) {
    clearInterval(focusInterval);
    focusInterval = null;
  }
});

// Study button repeated action on mousedown/up
let studyInterval = null;
document.getElementById("studyBtn").addEventListener("mousedown", () => {
  if (game.resting) return;
  if (studyInterval) return;
  // Perform once immediately
  performStudyRepeatedly();
  studyInterval = setInterval(() => {
    if (game.resting) {
      clearInterval(studyInterval);
      studyInterval = null;
      return;
    }
    if (!game.unlocked.study || game.mana < 5) {
      clearInterval(studyInterval);
      studyInterval = null;
      return;
    }
    performStudyRepeatedly();
    updateUI();
  }, 500);
});
document.getElementById("studyBtn").addEventListener("mouseup", () => {
  if (studyInterval) {
    clearInterval(studyInterval);
    studyInterval = null;
  }
});
document.getElementById("studyBtn").addEventListener("mouseleave", () => {
  if (studyInterval) {
    clearInterval(studyInterval);
    studyInterval = null;
  }
});

// Meditate button (formerly Rest) repeated action on mousedown/up
// For meditate, the behavior is a 5 second meditation with delayed energy gain; repeating is not meaningful.
// We keep single click behavior and update all text/logs.
document.getElementById("restBtn").onclick = () => {
  if (game.resting) {
    log("You are already meditating...");
    return;
  }
  game.resting = true;
  log("You begin to meditate for 5 seconds...");
  disableActions(true);
  const timerMsgEl = document.getElementById("timerMessage");
  let remaining = 5;
  timerMsgEl.textContent = "Meditating... " + remaining + "s remaining";
  const interval = setInterval(() => {
    remaining--;
    if (remaining > 0) {
      timerMsgEl.textContent = "Meditating... " + remaining + "s remaining";
    } else {
      clearInterval(interval);
      timerMsgEl.textContent = "";
    }
  }, 1000);
  setTimeout(() => {
    game.energy += 5;
    game.resting = false;
    log(`You feel renewed. Energy +5 (Energy: ${Math.floor(game.energy)})`);
    disableActions(false);
    gainLoreIfFirst("meditate", "Your mind clears and energy flows anew.");
    timerMsgEl.textContent = "";
    updateUI();
  }, 5000);
};

// Climb button repeated action on mousedown/up
// Because climbing involves prompts and random events, repeated climbing on hold is not practical or user-friendly.
// We will keep original single click behavior only.
document.getElementById("climbBtn").onclick = () => {
  const floorCost = getFloorCost(game.floor);
  if (game.energy < floorCost) {
    log("You are too tired to climb.");
    return;
  }

  // Special floor 5 event: choose path
  if (game.floor === 5) {
    let choice = prompt("You reach Floor 5: Choose your path (left/right):");
    if (choice) choice = choice.toLowerCase();
    while (choice !== "left" && choice !== "right") {
      choice = prompt("Invalid choice. Please choose 'left' or 'right':");
      if (choice) choice = choice.toLowerCase();
    }
    if (choice === "left") {
      // left path costs more energy but gives mana
      const leftCost = floorCost + 2;
      if (game.energy < leftCost) {
        log("You don't have enough energy for the left path. You take the right path instead.");
        // right path: safe, normal cost
        game.energy -= floorCost;
        log(`You take the right path, safe but uneventful. Energy -${floorCost} (Energy: ${Math.floor(game.energy)})`);
      } else {
        game.energy -= leftCost;
        game.mana += 3;
        log(`You take the left path, draining but mana-rich. Energy -${leftCost} (Energy: ${Math.floor(game.energy)}), Mana +3 (Mana: ${Math.floor(game.mana)})`);
      }
    } else {
      // right path: safe, normal cost
      game.energy -= floorCost;
      log(`You take the right path, safe but uneventful. Energy -${floorCost} (Energy: ${Math.floor(game.energy)})`);
    }
  }
  // Special floor 8 event: mystical trap
  else if (game.floor === 8) {
    if (game.inventory["Glyph Shard"] > 0) {
      useItem("Glyph Shard");
      log("A mystical trap triggers but your Glyph Shard protects you.");
      game.energy -= floorCost;
      log(`Energy -${floorCost} (Energy: ${Math.floor(game.energy)})`);
    } else {
      game.energy -= floorCost;
      const lostEnergy = Math.min(2, Math.floor(game.energy));
      game.energy -= lostEnergy;
      log(`A mystical trap drains your energy! Energy -${floorCost + lostEnergy} (Energy: ${Math.floor(game.energy)})`);
    }
  }
  else {
    // normal floors
    game.energy -= floorCost;
    log(`Energy -${floorCost} (Energy: ${Math.floor(game.energy)})`);
  }

  if (!game.startTime) game.startTime = Date.now();
  game.floor++;
  log(`You ascend to Floor ${game.floor}. (Floor: ${game.floor})`);

  // Random event (50% chance)
  if (Math.random() < 0.5) {
    randomFloorEvent();
  }

  // Random drop chance (30%)
  if (Math.random() < 0.3) {
    const items = ["Energy Potion", "Mana Crystal", "Glyph Shard"];
    const foundItem = items[Math.floor(Math.random() * items.length)];
    addItem(foundItem);
  }

  if (game.floor % 3 === 0) {
    game.lore++;
    log(`You uncover new lore as you climb. Lore +1 (Lore: ${game.lore})`);
  }

  if (game.floor >= 10) {
    const elapsed = (Date.now() - game.startTime) / 1000;
    if (elapsed <= 120) {
      game.tempo++;
      log(`You‚Äôve reached Floor 10 in record time! Tempo +1 (Tempo: ${game.tempo})`);
    } else {
      log("You‚Äôve reached Floor 10. The tower hums with quiet power...");
    }
    game.startTime = null;
  }
  updateUI();
};

function gainLoreIfFirst(action, message) {
  // For backwards compatibility: treat both "rest" and "meditate" as the same unlock
  const key = action === "rest" ? "meditate" : action;
  if (!game.unlocked[key]) {
    game.unlocked[key] = true;
    log(message);
    game.lore++;
    if (game.lore >= 2 && !game.unlocked.study) {
      game.unlocked.study = true;
      log("You‚Äôve unlocked the ability to Study Glyphs!");
    }
    if  (game.lore >= 4 && !game.unlocked.climb) {
      game.unlocked.climb = true;
      log("You feel the pull of the tower above you... You may now climb!");
    }
  }
  updateUI();
}

// ---- Save / Load ----
function saveGame() {
  localStorage.setItem("tower_autosave", JSON.stringify(game));
}

// Load game from localStorage or imported save, restoring flavored refresh/sessionStorage logic
function loadGame(imported) {
  let saveObj = null;
  if (typeof imported === "object" && imported !== null) {
    saveObj = imported;
  } else {
    const data = localStorage.getItem("tower_autosave"); // <-- updated key
    if (data) {
      try {
        saveObj = JSON.parse(data);
      } catch (e) {
        saveObj = null;
      }
    }
  }

  if (saveObj) {
    // Restore all properties
    Object.assign(game, saveObj);

    // Ensure logHistory is newest-first
    if (Array.isArray(game.logHistory) && game.logHistory.length > 1) {
      const getTS = s => s && s[0] === "[" ? s.slice(1, 15) : "";
      if (getTS(game.logHistory[0]) < getTS(game.logHistory[1])) {
        game.logHistory.reverse();
      }
    }

    // Render the log
    const logDiv = document.getElementById("log");
    logDiv.textContent = game.logHistory.join("\n");
    logDiv.scrollTop = 0;

    log("Save loaded.");
  } else {
    game.logHistory = [];
    log("A new journey begins...");
  }

  updateUI();
  scheduleAutosave();
}
function loadGame(imported) {
  let saveObj = null;
  let loadedFromImport = false;
  if (typeof imported === "object" && imported !== null) {
    saveObj = imported;
    loadedFromImport = true;
  } else {
    const data = localStorage.getItem("mages_tower_save");
    if (data) {
      try {
        saveObj = JSON.parse(data);
      } catch (e) {
        saveObj = null;
      }
    }
  }
  if (saveObj) {
    // Restore all main properties
    if (typeof saveObj.energy === "number") game.energy = saveObj.energy;
    if (typeof saveObj.mana === "number") game.mana = saveObj.mana;
    if (typeof saveObj.lore === "number") game.lore = saveObj.lore;
    if (typeof saveObj.floor === "number") game.floor = saveObj.floor;
    if (typeof saveObj.tempo === "number") game.tempo = saveObj.tempo;
    if (typeof saveObj.resting === "boolean") game.resting = saveObj.resting;
    if (typeof saveObj.startTime === "number" || saveObj.startTime === null) game.startTime = saveObj.startTime;
    if (typeof saveObj.lastTick === "number") game.lastTick = saveObj.lastTick;
    if (typeof saveObj.unlocked === "object" && saveObj.unlocked) {
      game.unlocked = Object.assign({}, saveObj.unlocked);
    }
    if (typeof saveObj.inventory === "object" && saveObj.inventory) {
      game.inventory = Object.assign({ "Energy Potion": 0, "Mana Crystal": 0, "Glyph Shard": 0 }, saveObj.inventory);
    }
    // Log history (restore newest-first order)
    if (Array.isArray(saveObj.logHistory)) {
      let hist = saveObj.logHistory.slice();
      if (hist.length > 1) {
        const getTS = s => s && s[0] === "[" ? s.slice(1, 15) : "";
        if (getTS(hist[0]) < getTS(hist[1])) {
          hist.reverse();
        }
      }
      game.logHistory = hist;
    } else {
      game.logHistory = [];
    }
    // Render logHistory newest at top
    const logDiv = document.getElementById("log");
    logDiv.textContent = game.logHistory.join('\n');
    logDiv.scrollTop = 0;
    // Flavored refresh/sessionStorage logic
    let flavored = false;
    if (!loadedFromImport && typeof sessionStorage !== "undefined") {
      // If sessionStorage.mages_tower_flavored_refresh is set, show flavored message and clear it
      if (sessionStorage.getItem("mages_tower_flavored_refresh")) {
        sessionStorage.removeItem("mages_tower_flavored_refresh");
        log("You awaken, memories of your ascent swirling in your mind. (Game state restored after refresh)");
        flavored = true;
      }
    }
    if (!flavored && !loadedFromImport) {
      log("Save loaded.");
    }
    // For imported saves, do not log "Save loaded." (importers handle their own log)
  } else {
    game.logHistory = [];
    document.getElementById("log").textContent = "";
    log("A new journey begins...");
  }
  updateUI();
  scheduleAutosave();
}

// --- Auto-refresh logic REMOVED ---
// (Auto-refresh, setInterval, and focus/blur listeners have been disabled as requested.)


// ---- Export / Import ----
document.getElementById("exportBtn").onclick = () => {
  const blob = new Blob([JSON.stringify(game, null, 2)], {type: "application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "tower_autosave.json";
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    URL.revokeObjectURL(a.href);
    document.body.removeChild(a);
  }, 100);
};

document.getElementById("importBtn").onclick = () => {
  document.getElementById("fileInput").click();
};

document.getElementById("fileInput").addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const imported = JSON.parse(reader.result);
      loadGame(imported);
    } catch (err) {
      log("Failed to import save file.");
    }
  };
  reader.readAsText(file);
});

window.onload = () => {
  loadGame();
};
</script>
</body>
</html>
